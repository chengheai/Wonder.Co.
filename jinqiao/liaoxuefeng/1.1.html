<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    // ========函數==============
    // function foo(a,b,c){
    //   if(arguments.length ===3){
    //     console.log('参数是3个')
    //   }
    // }
    // foo(0,2,5) // arguments跟你调用时候传进来的参数挂钩
    // function foo(a, b) {
    //   var i, rest = [];
    //   if (arguments.length > 2) {
    //       for (i = 2; i<arguments.length; i++) {
    //           rest.push(arguments[i]);
    //       }
    //   }
    //   console.log('a = ' + a);
    //   console.log('b = ' + b);
    //   console.log(rest);
    // }
    // foo(1,2)
    // function foo(a,b,...rest){
    //   console.log('a:',a)
    //   console.log('b:',b)
    //   console.log('...rest:',...rest)
    // }
    // foo(1,2,3,4,5)
    // ======return=======
    // ===javascript 行末自动添加分号机制
    // function foo() {
    //   return { name: 'foo' };
    // }
    // foo(); // { name: 'foo' }
    // function foo() {
    //   return
    //     { name: 'foo' };
    //   }
    // foo(); // undefined

    // function foo() {
    //   var x = 'Hello, ' + y;
    //   console.log(x);
    //   var y = 'Bob';
    // }
    // foo(); // hello undefined

    // function foo() {
    //   alert('foo');
    // }
    // foo(); // 直接调用foo()
    // window.foo(); // 通过window.foo()调用
    // var xiaoming = {
    //   name: '小明',
    //   birth: 1990,
    //   age: function () {
    //     var y = new Date().getFullYear();
    //     return y - this.birth;
    //   }
    // };

    // var fn = xiaoming.age;
    // console.log(fn()); // Uncaught TypeError: Cannot read property 'birth' of undefined  NaN
  //   var xiaoming = {
  //   name: '小明',
  //   birth: 1990,
  //   age: function () {
  //     console.log(this)
  //     var that = this; // 在方法内部一开始就捕获this
      
  //     console.log(that)
  //     function getAgeFromBirth() {
  //         var y = new Date().getFullYear();
  //         return y - that.birth; // 用that而不是this
  //     }
  //     return getAgeFromBirth();
  //   }
  // };

  // console.log(xiaoming.age()); // 25
  //  =======apply======
  //要指定函数的this指向哪个对象，
  // 可以用函数本身的apply方法，
  // 它接收两个参数，第一个参数就是需
  // 要绑定的this变量，第二个参数是Array
  // ，表示函数本身的参数。
  // function getAge(a){
  //   console.log('a:',a)
  //   var y = new Date().getFullYear();
  //   return y - this.birth;
  // }
  // var xiaoming = {
  //   name: '小明',
  //   birth: 1990,
  //   age: getAge
  // }
  // console.log(xiaoming.age(1))
  // console.log(getAge.apply(xiaoming, [1]));

  // 另一个与apply()类似的方法是call()
  // ，唯一区别是：
  // apply()把参数打包成Array再传入；
  // call()把参数按顺序传入。
  /*
    Math.max.apply(null, [3, 5, 4]); // 5
    Math.max.call(null, 3, 5, 4); // 5
  */

  ////     ========m面試
  // 下面的语句返回什么呢:
["1", "2", "3"].map(parseInt);
// 你可能觉的会是[1, 2, 3]
// 但实际的结果是 [1, NaN, NaN]

// 通常使用parseInt时,只需要传递一个参数.
// 但实际上,parseInt可以有两个参数.第二个参数是进制数.
// 可以通过语句"alert(parseInt.length)===2"来验证.
// map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 
// 元素索引, 原数组本身.
// 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,
// parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.

// function returnInt(element) {
//   return parseInt(element, 10);
// }

// ['1', '2', '3'].map(returnInt); // [1, 2, 3]
// // 意料之中的结果

// // 也可以使用简单的箭头函数，结果同上
// ['1', '2', '3'].map( str => parseInt(str) );

// // 一个更简单的方式:
// ['1', '2', '3'].map(Number); // [1, 2, 3]
// // 与`parseInt` 不同，下面的结果会返回浮点数或指数:
// ['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]
// ======filter
// var arr = ['A', '', 'B', null, undefined, 'C', '  '];
// var r = arr.filter(function (s) {
//     return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
// });
// console.log('r:',r); // ['A', 'B', 'C']

 /// arguments
// var arr = ['A', 'B', 'C'];
// var r = arr.filter(function (element, index, self) {
//   console.log(element); // 依次打印'A', 'B', 'C'
//   console.log(index); // 依次打印0, 1, 2
//   console.log(self); // self就是变量arr
//   return true;
// });

// 依據 ；
/*
去除重复元素依靠的是
indexOf总是返回第一个元素的位置，
后续的重复元素位置与indexOf返回的
位置不相等，因此被filter滤掉了。
*/
// var
//     r,
//     arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];
//     r = arr.filter(function (element, index, self) {
//     return self.indexOf(element) === index;
// });
// console.log(r.toString());

/// ==========sort
//ASCII码排序
// var arr = [10,20,1,2];
// //console.log(arr.sort())  //[1, 10, 2, 20]
// arr.sort(function (x, y) {
//     if (x < y) {
//         return -1;
//     }
//     if (x > y) {
//         return 1;
//     }
//     return 0;
// });
// console.log(arr); // [1, 2, 10, 20]

 /// abcd排序=========
// var arr = ['Google', 'apple', 'Microsoft'];
// arr.sort(function (s1, s2) {
//     x1 = s1.toUpperCase();
//     x2 = s2.toUpperCase();
//     if (x1 < x2) {
//         return -1;
//     }
//     if (x1 > x2) {
//         return 1;
//     }
//     return 0;
// }); // ['apple', 'Google', 'Microsoft']

// sort()方法会直接对Array进行修改，
// 它返回的结果仍是当前Array：
// var a1 = ['B', 'A', 'C'];
// var a2 = a1.sort();
// a1; // ['A', 'B', 'C']
// a2; // ['A', 'B', 'C']
// a1 === a2; // true, a1和a2是同一对象

</script>
</body>
</html>